{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, inject, PLATFORM_ID, Injectable, Inject, Self } from '@angular/core';\nimport { actionMatcher, InitState, UpdateState, getValue, setValue, Store, NGXS_PLUGINS } from '@ngxs/store';\nimport { isPlatformServer } from '@angular/common';\nimport { isSimpleObject, isGetter } from '@angular-ru/cdk/object';\nimport { isNil, isNotNil, isFalsy, isTruthy, checkValueIsEmpty, checkValueIsFilled } from '@angular-ru/cdk/utils';\nimport { getStateMetadata, NgxsDataInjector, STORAGE_INIT_EVENT } from '@angular-ru/ngxs/internals';\nimport { NGXS_DATA_STORAGE_EVENT_TYPE } from '@angular-ru/ngxs/tokens';\nimport { interval, ReplaySubject, fromEvent } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nconst NGXS_DATA_STORAGE_CONTAINER_TOKEN = new InjectionToken('NGXS_DATA_STORAGE_CONTAINER_TOKEN');\n\nclass NgxsDataStorageContainer {\n  constructor() {\n    this.providers = new Set();\n    this.keys = new Map();\n  }\n\n  getProvidedKeys() {\n    return Array.from(this.keys.keys());\n  }\n\n}\n\nfunction storageUseFactory() {\n  return new NgxsDataStorageContainer();\n}\n\nconst NGXS_DATA_STORAGE_CONTAINER = {\n  provide: NGXS_DATA_STORAGE_CONTAINER_TOKEN,\n  useFactory: storageUseFactory\n};\nconst NGXS_DATA_STORAGE_DECODE_TYPE_TOKEN = new InjectionToken('NGXS_DATA_STORAGE_DECODE_TYPE_TOKEN');\nconst NGXS_DATA_STORAGE_DECODE_TYPE = {\n  provide: NGXS_DATA_STORAGE_DECODE_TYPE_TOKEN,\n  useValue: \"none\"\n  /* NONE */\n\n};\n\nfunction existTtl(provider) {\n  return provider.ttl !== -1 && !isNaN(provider.ttl) && provider.ttl > 0;\n}\n\nfunction isExpiredByTtl(expiry) {\n  return isNil(expiry) ? true : Date.now() >= expiry.getTime();\n}\n\nfunction canBePullFromStorage(options) {\n  const {\n    data,\n    provider\n  } = options;\n  const canBeOverrideFromStorage = isNotNil(data) || provider.nullable;\n  let result = {\n    canBeOverrideFromStorage,\n    versionMismatch: false,\n    expired: false,\n    expiry: null\n  };\n  result = ensureInfoByTtl(canBeOverrideFromStorage, result, options);\n  result = ensureInfoByVersionMismatch(canBeOverrideFromStorage, result, options);\n  return result;\n}\n\nfunction ensureInfoByTtl(canBeOverrideFromStorage, result, options) {\n  let newResult = result;\n  const {\n    meta,\n    provider\n  } = options;\n\n  if (canBeOverrideFromStorage && existTtl(provider)) {\n    const expiry = new Date(meta.expiry);\n    const expiryExist = !isNaN(expiry.getTime());\n\n    if (expiryExist) {\n      if (isExpiredByTtl(expiry)) {\n        newResult = {\n          canBeOverrideFromStorage: false,\n          expired: true,\n          expiry,\n          versionMismatch: false\n        };\n      } else {\n        newResult = {\n          canBeOverrideFromStorage,\n          expired: false,\n          expiry,\n          versionMismatch: false\n        };\n      }\n    }\n  }\n\n  return newResult;\n}\n\nfunction ensureInfoByVersionMismatch(canBeOverrideFromStorage, result, options) {\n  let newResult = result;\n  const {\n    meta,\n    provider\n  } = options;\n\n  if (canBeOverrideFromStorage && meta.version !== provider.version) {\n    const instance = provider.stateInstance;\n    const tryMigrate = isFalsy(provider.skipMigrate) && (isTruthy(instance === null || instance === void 0 ? void 0 : instance.ngxsDataStorageMigrate) || isTruthy(provider.migrate));\n\n    if (tryMigrate) {\n      newResult = Object.assign(Object.assign({}, result), {\n        versionMismatch: true\n      });\n    } else {\n      newResult = Object.assign(Object.assign({}, result), {\n        canBeOverrideFromStorage: false,\n        versionMismatch: true\n      });\n    }\n  }\n\n  return newResult;\n}\n\nfunction ensurePath(provider) {\n  var _a;\n\n  return (_a = provider.path) !== null && _a !== void 0 ? _a : getStateMetadata(provider.stateClassRef).path;\n}\n\nfunction ensureKey(provider) {\n  return `${provider.prefixKey}${ensurePath(provider)}`;\n}\n\nfunction firedStateWhenExpired(key, options) {\n  var _a, _b, _c;\n\n  const {\n    provider,\n    expiry\n  } = options;\n  const event = {\n    key,\n    expiry: expiry === null || expiry === void 0 ? void 0 : expiry.toISOString(),\n    timestamp: new Date(Date.now()).toISOString()\n  };\n  const instance = provider.stateInstance;\n  (_a = instance === null || instance === void 0 ? void 0 : instance.expired$) === null || _a === void 0 ? void 0 : _a.next(event);\n\n  if (isNotNil(instance === null || instance === void 0 ? void 0 : instance.ngxsDataAfterExpired)) {\n    if (isNotNil(NgxsDataInjector.ngZone)) {\n      (_b = NgxsDataInjector.ngZone) === null || _b === void 0 ? void 0 : _b.run(() => {\n        var _a;\n\n        return (_a = instance === null || instance === void 0 ? void 0 : instance.ngxsDataAfterExpired) === null || _a === void 0 ? void 0 : _a.call(instance, event, provider);\n      });\n    } else {\n      (_c = instance === null || instance === void 0 ? void 0 : instance.ngxsDataAfterExpired) === null || _c === void 0 ? void 0 : _c.call(instance, event, provider);\n    }\n  }\n}\n\nconst SPACE = 4;\n\nclass InvalidStructureDataException extends Error {\n  constructor(message) {\n    super(`${message}. \\nIncorrect structure for deserialization!!! Your structure should be like this: \\n${JSON.stringify({\n      lastChanged: '2020-01-01T12:00:00.000Z',\n      data: '{}',\n      version: 1\n    }, null, SPACE)}`);\n  }\n\n}\n\nfunction parseStorageMeta(value) {\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    throw new InvalidStructureDataException(e.message);\n  }\n}\n\nfunction ttlStrategyHandler(key, value, options) {\n  const {\n    provider,\n    engine\n  } = options;\n  const meta = parseStorageMeta(value);\n\n  switch (provider.ttlExpiredStrategy) {\n    case 0\n    /* REMOVE_KEY_AFTER_EXPIRED */\n    :\n      engine.removeItem(key);\n      break;\n\n    case 1\n    /* SET_NULL_DATA_AFTER_EXPIRED */\n    :\n      meta.data = null;\n      engine.setItem(key, JSON.stringify(meta));\n      break;\n\n    case 2\n    /* DO_NOTHING_AFTER_EXPIRED */\n    :\n    default:\n      break;\n  }\n}\n\nfunction ttlHandler(start, options, subscription) {\n  const {\n    provider,\n    expiry,\n    map,\n    engine\n  } = options;\n  const key = ensureKey(provider);\n  const value = engine.getItem(key);\n\n  if (isNotNil(value)) {\n    if (isExpiredByTtl(expiry)) {\n      const endListen = new Date(Date.now()).toISOString();\n      ttlStrategyHandler(key, value, options);\n      firedStateWhenExpired(key, options);\n      subscription.unsubscribe();\n      map.set(provider, {\n        subscription,\n        startListen: start,\n        endListen\n      });\n    }\n  } else {\n    subscription.unsubscribe();\n  }\n}\n\nfunction createTtlInterval(options) {\n  var _a, _b;\n\n  const {\n    provider,\n    map\n  } = options;\n  (_a = map.get(provider)) === null || _a === void 0 ? void 0 : _a.subscription.unsubscribe();\n\n  const watcher = () => {\n    const startListen = new Date(Date.now()).toISOString();\n    const subscription = interval(provider.ttlDelay).subscribe(() => ttlHandler(startListen, options, subscription));\n    map.set(provider, {\n      subscription,\n      startListen,\n      endListen: null\n    });\n  };\n\n  if (isNotNil(NgxsDataInjector.ngZone)) {\n    (_b = NgxsDataInjector.ngZone) === null || _b === void 0 ? void 0 : _b.runOutsideAngular(() => watcher());\n  } else {\n    watcher();\n  }\n}\n\nclass InvalidDataValueException extends Error {\n  constructor() {\n    super(`missing key 'data' or it's value not serializable.`);\n  }\n\n}\n\nclass InvalidLastChangedException extends Error {\n  constructor(value) {\n    super(`lastChanged key not found in object ${value}.`);\n  }\n\n}\n\nclass InvalidVersionException extends Error {\n  constructor(value) {\n    super(`It's not possible to determine version (${value}), since it must be a integer type and must equal or more than 1.`);\n  }\n\n}\n\nfunction deserializeByStorageMeta(meta, value, provider) {\n  if (isSimpleObject(meta)) {\n    if (missingLastChanged(meta)) {\n      throw new InvalidLastChangedException(value);\n    } else if (versionIsInvalid(meta)) {\n      throw new InvalidVersionException(meta.version);\n    } else if (missingDataKey(meta)) {\n      throw new InvalidDataValueException();\n    }\n\n    return provider.decode === \"base64\"\n    /* BASE64 */\n    ? JSON.parse(window.atob(meta.data)) : meta.data;\n  } else {\n    throw new InvalidStructureDataException(`\"${value}\" not an object`);\n  }\n}\n\nfunction versionIsInvalid(meta) {\n  const version = parseFloat(meta.version);\n  return isNaN(version) || version < 1 || parseInt(meta.version) !== version;\n}\n\nfunction missingDataKey(meta) {\n  return !('data' in meta);\n}\n\nfunction missingLastChanged(meta) {\n  return !('lastChanged' in meta) || checkValueIsEmpty(meta.lastChanged);\n}\n\nfunction ensureSerializeData(data, provider) {\n  const dataLocal = isNotNil(data) ? data : null;\n  return provider.decode === \"base64\"\n  /* BASE64 */\n  ? window.btoa(JSON.stringify(dataLocal)) : dataLocal;\n}\n\nclass NotDeclareEngineException extends Error {\n  constructor(key) {\n    super(`${\"Not found storage engine from `existingEngine` or not found instance after injecting by `useClass`.\"\n    /* NGXS_PERSISTENCE_ENGINE */\n    } \\nMetadata { key: '${key}' }`);\n  }\n\n}\n\nclass NotImplementedStorageException extends Error {\n  constructor() {\n    super(`StorageEngine instance should be implemented by DataStorageEngine interface`);\n  }\n\n}\n\nfunction exposeEngine(provider, injector) {\n  var _a;\n\n  const engine = (_a = provider.existingEngine) !== null && _a !== void 0 ? _a : injector.get(provider.useClass, null);\n\n  if (isNil(engine)) {\n    throw new NotDeclareEngineException(ensureKey(provider));\n  } else if (!('getItem' in engine)) {\n    throw new NotImplementedStorageException();\n  }\n\n  return engine;\n}\n\nfunction isInitAction(action) {\n  const matches = actionMatcher(action);\n  return matches(InitState) || matches(UpdateState);\n}\n\nfunction isStorageEvent(action) {\n  return action.type === NGXS_DATA_STORAGE_EVENT_TYPE;\n} // eslint-disable-next-line max-lines-per-function\n\n\nfunction rehydrate(params) {\n  var _a, _b;\n\n  let states = params.states;\n  const {\n    provider,\n    data,\n    info\n  } = params;\n\n  if (isFalsy(provider.rehydrate)) {\n    return {\n      states,\n      rehydrateIn: false\n    };\n  }\n\n  const path = ensurePath(provider);\n  const prevData = getValue(states, path);\n\n  if (isTruthy(info.versionMismatch)) {\n    const stateInstance = provider.stateInstance;\n    const instance = stateInstance;\n    const migrateFn = (_a = provider.migrate) !== null && _a !== void 0 ? _a : (_b = instance.ngxsDataStorageMigrate) === null || _b === void 0 ? void 0 : _b.bind(provider.stateInstance);\n    const newMigrationData = migrateFn === null || migrateFn === void 0 ? void 0 : migrateFn(prevData, data);\n    states = setValue(states, path, newMigrationData);\n    return {\n      states,\n      rehydrateIn: true\n    };\n  } else if (JSON.stringify(prevData) !== JSON.stringify(data)) {\n    states = setValue(states, path, data);\n    return {\n      states,\n      rehydrateIn: true\n    };\n  }\n\n  return {\n    states,\n    rehydrateIn: false\n  };\n}\n\nfunction silentDeserializeWarning(key, value, error) {\n  console.warn(`${\"Error occurred while deserializing value\"\n  /* NGXS_PERSISTENCE_DESERIALIZE */\n  } from metadata { key: '${key}', value: '${value}' }. \\nError deserialize: ${error}`);\n}\n\nfunction silentSerializeWarning(key, error) {\n  console.warn(`${\"Error occurred while serializing value\"\n  /* NGXS_PERSISTENCE_SERIALIZE */\n  } from metadata { key: '${key}' }. \\nError serialize: ${error}`);\n}\n\nclass NgxsDataStoragePlugin {\n  constructor(platformId, injector) {\n    this.platformId = platformId;\n    NgxsDataStoragePlugin.injector = injector;\n    STORAGE_INIT_EVENT.events$.next();\n    this.listenWindowEvents();\n  }\n\n  get store() {\n    return NgxsDataStoragePlugin.injector.get(Store, null);\n  }\n\n  get size() {\n    return this.providers.size;\n  }\n\n  get ttlListeners() {\n    return NgxsDataStoragePlugin.ttlListeners;\n  }\n  /**\n   * @description:\n   * The storage container that contains meta information about\n   */\n\n\n  get container() {\n    return NgxsDataStoragePlugin.injector.get(NGXS_DATA_STORAGE_CONTAINER_TOKEN);\n  }\n  /**\n   * @description:\n   * Meta information about all the added keys and their options\n   */\n\n\n  get providers() {\n    return this.container.providers;\n  }\n  /**\n   * @description:\n   * Keys needed for dynamic synchronization with StorageEvents from\n   * localStorage or sessionStorage\n   */\n\n\n  get keys() {\n    return this.container.keys;\n  }\n\n  get entries() {\n    return this.providers.entries();\n  }\n\n  get skipStorageInterceptions() {\n    return this.size === 0 || isPlatformServer(this.platformId);\n  }\n\n  static checkIsStorageEvent(options, info, data) {\n    var _a;\n\n    const {\n      action,\n      provider,\n      key,\n      value\n    } = options;\n\n    if (isTruthy(info.rehydrateIn) && isTruthy(isStorageEvent(action))) {\n      const instance = provider.stateInstance;\n      const event = {\n        key,\n        value,\n        data,\n        provider\n      };\n      instance === null || instance === void 0 ? void 0 : instance.browserStorageEvents$.next(event);\n\n      if (isTruthy(instance === null || instance === void 0 ? void 0 : instance.ngxsDataAfterStorageEvent)) {\n        (_a = instance === null || instance === void 0 ? void 0 : instance.ngxsDataAfterStorageEvent) === null || _a === void 0 ? void 0 : _a.call(instance, event);\n      }\n    }\n  }\n\n  static mutateProviderWithInjectStateInstance(provider) {\n    var _a, _b;\n\n    if (isFalsy(provider.stateInstance)) {\n      try {\n        provider.stateInstance = (_b = (_a = NgxsDataStoragePlugin.injector) === null || _a === void 0 ? void 0 : _a.get(provider.stateClassRef, null)) !== null && _b !== void 0 ? _b : inject(provider.stateClassRef);\n      } catch (_c) {}\n    }\n  }\n\n  static checkExpiredInit(params) {\n    const {\n      info,\n      rehydrateInfo,\n      options,\n      map\n    } = params;\n    const {\n      provider,\n      engine\n    } = options;\n\n    if (isTruthy(rehydrateInfo.rehydrateIn) && isTruthy(info.expiry)) {\n      createTtlInterval({\n        provider,\n        expiry: info.expiry,\n        map,\n        engine\n      });\n    }\n  }\n\n  static canBeSyncStoreWithStorage(action, init) {\n    return init || action.type === NGXS_DATA_STORAGE_EVENT_TYPE;\n  }\n\n  handle(states, action, next) {\n    if (this.skipStorageInterceptions) {\n      return next(states, action);\n    }\n\n    const init = isInitAction(action);\n\n    for (const [provider] of this.entries) {\n      NgxsDataStoragePlugin.mutateProviderWithInjectStateInstance(provider);\n    }\n\n    const newStates = this.pullStateFromStorage(states, {\n      action,\n      init\n    });\n    return next(newStates, action).pipe(tap(nextState => this.pushStateToStorage(newStates, nextState, {\n      action,\n      init\n    })));\n  }\n\n  serialize(data, provider) {\n    const meta = {\n      version: provider.version,\n      lastChanged: new Date().toISOString(),\n      data: ensureSerializeData(data, provider)\n    };\n\n    if (isTruthy(existTtl(provider))) {\n      const engine = exposeEngine(provider, NgxsDataStoragePlugin.injector);\n      const expiry = new Date(Date.now() + parseInt(provider.ttl));\n      createTtlInterval({\n        provider,\n        expiry,\n        map: this.ttlListeners,\n        engine\n      });\n      meta.expiry = expiry.toISOString();\n    }\n\n    return JSON.stringify(meta);\n  }\n\n  deserialize(meta, value, provider) {\n    return deserializeByStorageMeta(meta, value, provider);\n  }\n\n  destroyOldTasks() {\n    var _a;\n\n    if (isTruthy(STORAGE_INIT_EVENT.firstInitialized)) {\n      STORAGE_INIT_EVENT.events$.complete();\n      STORAGE_INIT_EVENT.events$ = new ReplaySubject(1);\n    }\n\n    (_a = NgxsDataStoragePlugin.eventsSubscriptions) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    NgxsDataStoragePlugin.ttlListeners = new WeakMap();\n  }\n\n  pushStateToStorage(states, nextState, meta) {\n    for (const [provider] of this.entries) {\n      const prevData = getValue(states, ensurePath(provider));\n      const newData = getValue(nextState, ensurePath(provider));\n      const canBeInitFire = isTruthy(provider.fireInit) && meta.init;\n\n      if (prevData !== newData || canBeInitFire) {\n        const engine = exposeEngine(provider, NgxsDataStoragePlugin.injector);\n        const key = ensureKey(provider);\n\n        try {\n          const data = this.serialize(newData, provider);\n          engine.setItem(key, data);\n          this.keys.set(key);\n        } catch (error) {\n          silentSerializeWarning(key, error.message);\n        }\n      }\n    }\n  }\n\n  pullStateFromStorage(states, {\n    action,\n    init\n  }) {\n    let newStates = states;\n\n    if (NgxsDataStoragePlugin.canBeSyncStoreWithStorage(action, init)) {\n      for (const [provider] of this.entries) {\n        newStates = this.deserializeByProvider(newStates, action, provider);\n      }\n    }\n\n    return newStates;\n  }\n\n  deserializeByProvider(states, action, provider) {\n    let newState = states;\n    const key = ensureKey(provider);\n\n    if (!isGetter(provider, 'path')) {\n      provider.path = ensurePath(provider);\n    }\n\n    const engine = exposeEngine(provider, NgxsDataStoragePlugin.injector);\n    const value = engine.getItem(key);\n    const existValueByKeyInStorage = isNotNil(value);\n\n    if (existValueByKeyInStorage) {\n      newState = this.deserializeHandler(newState, {\n        key,\n        engine,\n        provider,\n        value,\n        action\n      });\n    }\n\n    return newState;\n  }\n\n  deserializeHandler(states, options) {\n    const {\n      key,\n      provider,\n      value\n    } = options;\n\n    try {\n      const meta = parseStorageMeta(value);\n      const data = this.deserialize(meta, value, provider);\n      const info = canBePullFromStorage({\n        provider,\n        meta,\n        data\n      });\n\n      if (isTruthy(info.canBeOverrideFromStorage)) {\n        const rehydrateInfo = rehydrate({\n          states,\n          provider,\n          data,\n          info\n        });\n        this.keys.set(key); // mutate parent states\n        // eslint-disable-next-line no-param-reassign\n\n        states = rehydrateInfo.states;\n        NgxsDataStoragePlugin.checkIsStorageEvent(options, rehydrateInfo, data);\n        NgxsDataStoragePlugin.checkExpiredInit({\n          info,\n          rehydrateInfo,\n          options,\n          map: this.ttlListeners\n        });\n      } else {\n        this.removeKeyWhenPullInvalid(info, options);\n      }\n    } catch (error) {\n      silentDeserializeWarning(key, value, error.message);\n    }\n\n    return states;\n  }\n\n  removeKeyWhenPullInvalid(info, options) {\n    const {\n      key,\n      engine,\n      provider\n    } = options;\n\n    if (isTruthy(info.expired)) {\n      firedStateWhenExpired(key, {\n        provider,\n        engine,\n        map: this.ttlListeners,\n        expiry: info.expiry\n      });\n    }\n\n    engine.removeItem(key);\n    this.keys.delete(key);\n  }\n\n  listenWindowEvents() {\n    if (isPlatformServer(this.platformId)) {\n      return;\n    }\n\n    this.destroyOldTasks();\n    NgxsDataStoragePlugin.eventsSubscriptions = fromEvent(window, 'storage').subscribe(event => {\n      const keyUsageInStore = checkValueIsFilled(event.key) && this.keys.has(event.key);\n\n      if (keyUsageInStore) {\n        // eslint-disable-next-line rxjs/no-nested-subscribe,rxjs/no-ignored-subscribe\n        this.store.dispatch({\n          type: NGXS_DATA_STORAGE_EVENT_TYPE\n        }).subscribe();\n      }\n    });\n  }\n\n}\n\nNgxsDataStoragePlugin.injector = null;\nNgxsDataStoragePlugin.eventsSubscriptions = null;\nNgxsDataStoragePlugin.ttlListeners = new WeakMap();\n/** @nocollapse */\n\n/** @nocollapse */\n\nNgxsDataStoragePlugin.ɵfac = function NgxsDataStoragePlugin_Factory(t) {\n  return new (t || NgxsDataStoragePlugin)(i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.Injector, 2));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNgxsDataStoragePlugin.ɵprov =\n/** @pureOrBreakMyCode */\ni0.ɵɵdefineInjectable({\n  token: NgxsDataStoragePlugin,\n  factory: NgxsDataStoragePlugin.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst NGXS_DATA_STORAGE_EXTENSION = {\n  provide: NGXS_PLUGINS,\n  useClass: NgxsDataStoragePlugin,\n  multi: true\n};\nconst NGXS_DATA_STORAGE_PREFIX_TOKEN = new InjectionToken('NGXS_DATA_STORAGE_PREFIX_TOKEN');\nconst DEFAULT_KEY_PREFIX = '@ngxs.store.';\nconst NGXS_DATA_STORAGE_PREFIX = {\n  provide: NGXS_DATA_STORAGE_PREFIX_TOKEN,\n  useValue: DEFAULT_KEY_PREFIX\n}; // eslint-disable-next-line @typescript-eslint/no-magic-numbers\n\nconst STORAGE_TTL_DELAY = 1000 * 60; // 1min\n// eslint-disable-next-line max-lines-per-function\n\nfunction createDefault(options) {\n  const {\n    meta,\n    decodeType,\n    prefix,\n    stateClassRef\n  } = options;\n  return [{\n    get path() {\n      var _a;\n\n      return (_a = meta === null || meta === void 0 ? void 0 : meta.stateMeta) === null || _a === void 0 ? void 0 : _a.path;\n    },\n\n    existingEngine: localStorage,\n    ttl: -1,\n    version: 1,\n    decode: decodeType,\n    prefixKey: prefix,\n    nullable: false,\n    fireInit: true,\n    rehydrate: true,\n    ttlDelay: STORAGE_TTL_DELAY,\n    ttlExpiredStrategy: 0\n    /* REMOVE_KEY_AFTER_EXPIRED */\n    ,\n    stateClassRef,\n    skipMigrate: false\n  }];\n}\n\nfunction validatePathInProvider(meta, provider) {\n  let newProvider = provider;\n\n  if (!('path' in newProvider)) {\n    newProvider = Object.assign(Object.assign({}, newProvider), {\n      get path() {\n        var _a;\n\n        return (_a = meta === null || meta === void 0 ? void 0 : meta.stateMeta) === null || _a === void 0 ? void 0 : _a.path;\n      }\n\n    });\n  }\n\n  return newProvider;\n} // eslint-disable-next-line complexity\n\n\nfunction mergeOptions({\n  option,\n  decodeType,\n  prefix,\n  meta,\n  stateClassRef\n}) {\n  const provider = Object.assign(option, {\n    ttl: isNotNil(option.ttl) ? option.ttl : -1,\n    version: isNotNil(option.version) ? option.version : 1,\n    decode: isNotNil(option.decode) ? option.decode : decodeType,\n    prefixKey: isNotNil(option.prefixKey) ? option.prefixKey : prefix,\n    nullable: isNotNil(option.nullable) ? option.nullable : false,\n    fireInit: isNotNil(option.fireInit) ? option.fireInit : true,\n    rehydrate: isNotNil(option.rehydrate) ? option.rehydrate : true,\n    ttlDelay: isNotNil(option.ttlDelay) ? option.ttlDelay : STORAGE_TTL_DELAY,\n    ttlExpiredStrategy: isNotNil(option.ttlExpiredStrategy) ? option.ttlExpiredStrategy : 0\n    /* REMOVE_KEY_AFTER_EXPIRED */\n    ,\n    stateClassRef: isNotNil(option.stateClassRef) ? option.stateClassRef : stateClassRef,\n    skipMigrate: isNotNil(option.skipMigrate) ? option.skipMigrate : false\n  });\n  return validatePathInProvider(meta, provider);\n} // eslint-disable-next-line max-lines-per-function\n\n\nfunction ensureProviders(meta, stateClassRef, options) {\n  var _a, _b, _c, _d;\n\n  let providers;\n  const prefix = (_b = (_a = NgxsDataStoragePlugin.injector) === null || _a === void 0 ? void 0 : _a.get(NGXS_DATA_STORAGE_PREFIX_TOKEN, DEFAULT_KEY_PREFIX)) !== null && _b !== void 0 ? _b : DEFAULT_KEY_PREFIX;\n  const decodeType = (_d = (_c = NgxsDataStoragePlugin.injector) === null || _c === void 0 ? void 0 : _c.get(NGXS_DATA_STORAGE_DECODE_TYPE_TOKEN, \"none\"\n  /* NONE */\n  )) !== null && _d !== void 0 ? _d : \"none\"\n  /* NONE */\n  ;\n\n  if (isNotNil(options)) {\n    const prepared = Array.isArray(options) ? options : [options];\n    providers = prepared.map(option => mergeOptions({\n      option,\n      prefix,\n      decodeType,\n      meta,\n      stateClassRef\n    }));\n  } else {\n    providers = createDefault({\n      meta,\n      prefix,\n      decodeType,\n      stateClassRef\n    });\n  }\n\n  return providers;\n}\n\nfunction registerStorageProviders(options) {\n  var _a;\n\n  try {\n    const container = (_a = NgxsDataStoragePlugin.injector) === null || _a === void 0 ? void 0 : _a.get(NGXS_DATA_STORAGE_CONTAINER_TOKEN);\n    options.forEach(option => {\n      container === null || container === void 0 ? void 0 : container.providers.add(option);\n    });\n  } catch (_b) {\n    throw new Error(\"You forgot provide NGXS_DATA_STORAGE_CONTAINER or NGXS_DATA_STORAGE_EXTENSION!!! Example: \\n\\n@NgModule({\\n imports: [ \\n   NgxsDataPluginModule.forRoot([NGXS_DATA_STORAGE_PLUGIN]) \\n ]\\n})\\nexport class AppModule {} \\n\\n\"\n    /* NGXS_PERSISTENCE_CONTAINER */\n    );\n  }\n}\n\nconst NGXS_DATA_STORAGE_PLUGIN = [NGXS_DATA_STORAGE_EXTENSION, NGXS_DATA_STORAGE_CONTAINER, NGXS_DATA_STORAGE_PREFIX, NGXS_DATA_STORAGE_DECODE_TYPE];\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_KEY_PREFIX, NGXS_DATA_STORAGE_CONTAINER, NGXS_DATA_STORAGE_CONTAINER_TOKEN, NGXS_DATA_STORAGE_DECODE_TYPE, NGXS_DATA_STORAGE_DECODE_TYPE_TOKEN, NGXS_DATA_STORAGE_EXTENSION, NGXS_DATA_STORAGE_PLUGIN, NGXS_DATA_STORAGE_PREFIX, NGXS_DATA_STORAGE_PREFIX_TOKEN, NgxsDataStorageContainer, NgxsDataStoragePlugin, STORAGE_TTL_DELAY, ensurePath, ensureProviders, isStorageEvent, registerStorageProviders, storageUseFactory }; //# sourceMappingURL=angular-ru-ngxs-storage.js.map","map":null,"metadata":{},"sourceType":"module"}