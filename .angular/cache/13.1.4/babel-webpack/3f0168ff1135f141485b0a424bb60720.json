{"ast":null,"code":"import { HttpResponseBase, HttpResponse, HttpErrorResponse } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nexport function nameof(key, instance) {\n  return key;\n}\nexport let Utilities = /*#__PURE__*/(() => {\n  class Utilities {\n    constructor() {}\n\n    static splitInTwo(text, separator) {\n      const separatorIndex = text.indexOf(separator);\n\n      if (separatorIndex === -1) {\n        return {\n          firstPart: text,\n          secondPart: null\n        };\n      }\n\n      const part1 = text.substr(0, separatorIndex).trim();\n      const part2 = text.substr(separatorIndex + 1).trim();\n      return {\n        firstPart: part1,\n        secondPart: part2\n      };\n    }\n\n    static baseUrl() {\n      let base = ''; // debugger;\n\n      if (window.location.origin) {\n        base = window.location.origin;\n      } else {\n        base = window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : '');\n      }\n\n      return base.replace(/\\/$/, '');\n    }\n\n    static safeStringify(object) {\n      let result;\n\n      try {\n        result = JSON.stringify(object);\n        return result;\n      } catch (error) {}\n\n      const simpleObject = {};\n\n      for (const prop in object) {\n        if (!object.hasOwnProperty(prop)) {\n          continue;\n        }\n\n        if (typeof object[prop] === 'object') {\n          continue;\n        }\n\n        if (typeof object[prop] === 'function') {\n          continue;\n        }\n\n        simpleObject[prop] = object[prop];\n      }\n\n      result = '[***Sanitized Object***]: ' + JSON.stringify(simpleObject);\n      return result;\n    }\n\n    static JsonTryParse(value) {\n      try {\n        return JSON.parse(value);\n      } catch (e) {\n        if (value === 'undefined') {\n          return void 0;\n        }\n\n        return value;\n      }\n    }\n\n    static getHttpResponseMessages(data) {\n      const responses = [];\n\n      if (data instanceof HttpResponseBase) {\n        if (this.checkNoNetwork(data)) {\n          responses.push(`${this.noNetworkMessageCaption}${this.captionAndMessageSeparator} ${this.noNetworkMessageDetail}`);\n        } else {\n          const responseObject = this.getResponseBody(data);\n\n          if (responseObject.error) {\n            if (responseObject.error.message != null) {\n              responses.push(responseObject.error.message);\n            }\n          } else if (responseObject && (typeof responseObject === 'object' || responseObject instanceof Object)) {\n            for (const key in responseObject) {\n              if (key) {\n                responses.push(`${key}${this.captionAndMessageSeparator} ${responseObject[key]}`);\n              } else if (responseObject[key]) {\n                responses.push(responseObject[key].toString());\n              }\n            }\n          }\n        }\n\n        if (!responses.length) {\n          if (data.body) {\n            responses.push(`body: ${data.body}`);\n          }\n\n          if (data.error) {\n            responses.push(`error: ${data.error}`);\n          }\n        }\n      }\n\n      if (!responses.length) {\n        if (this.getResponseBody(data)) {\n          responses.push(this.getResponseBody(data).toString());\n        } else {\n          responses.push(data.toString());\n        }\n      }\n\n      if (this.checkAccessDenied(data)) {\n        responses.splice(0, 0, `${this.accessDeniedMessageCaption}${this.captionAndMessageSeparator} ${this.accessDeniedMessageDetail}`);\n      }\n\n      if (this.checkNotFound(data)) {\n        let message = `${this.notFoundMessageCaption}${this.captionAndMessageSeparator} ${this.notFoundMessageDetail}`;\n\n        if (data.url) {\n          message += `. ${data.url}`;\n        }\n\n        responses.splice(0, 0, message);\n      }\n\n      return responses;\n    }\n\n    static getHttpResponseMessage(data) {\n      const httpMessage = Utilities.findHttpResponseMessage(Utilities.noNetworkMessageCaption, data) || Utilities.findHttpResponseMessage(Utilities.notFoundMessageCaption, data) || Utilities.findHttpResponseMessage('error_description', data) || Utilities.findHttpResponseMessage('error', data) || Utilities.getHttpResponseMessages(data).join();\n      return httpMessage;\n    }\n\n    static findHttpResponseMessage(messageToFind, data, seachInCaptionOnly = true, includeCaptionInResult = false) {\n      const searchString = messageToFind.toLowerCase();\n      const httpMessages = this.getHttpResponseMessages(data);\n\n      for (const message of httpMessages) {\n        const fullMessage = Utilities.splitInTwo(message, this.captionAndMessageSeparator);\n\n        if (fullMessage.firstPart && fullMessage.firstPart.toLowerCase().indexOf(searchString) !== -1) {\n          return includeCaptionInResult ? message : fullMessage.secondPart || fullMessage.firstPart;\n        }\n      }\n\n      if (!seachInCaptionOnly) {\n        for (const message of httpMessages) {\n          if (message.toLowerCase().indexOf(searchString) !== -1) {\n            if (includeCaptionInResult) {\n              return message;\n            } else {\n              const fullMessage = Utilities.splitInTwo(message, this.captionAndMessageSeparator);\n              return fullMessage.secondPart || fullMessage.firstPart;\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n\n    static getResponseBody(response) {\n      if (response instanceof HttpResponse) {\n        return response.body;\n      }\n\n      if (response instanceof HttpErrorResponse) {\n        return response.error || response.message || response.statusText;\n      }\n    }\n\n    static checkNoNetwork(response) {\n      if (response instanceof HttpResponseBase) {\n        return response.status === 0;\n      }\n\n      return false;\n    }\n\n    static checkAccessDenied(response) {\n      if (response instanceof HttpResponseBase) {\n        return response.status === 403;\n      }\n\n      return false;\n    }\n\n    static checkNotFound(response) {\n      if (response instanceof HttpResponseBase) {\n        return response.status === 404;\n      }\n\n      return false;\n    }\n\n    static checkIsLocalHost(url, base) {\n      if (url) {\n        const location = new URL(url, base);\n        return location.hostname === 'localhost' || location.hostname === '127.0.0.1';\n      }\n\n      return false;\n    }\n\n    static toTitleCase(text) {\n      return text.replace(/\\w\\S*/g, subString => {\n        return subString.charAt(0).toUpperCase() + subString.substr(1).toLowerCase();\n      });\n    }\n\n    static formatPhoneNumber(phoneNumber) {\n      const clean = phoneNumber.replace(/[\\(\\)-\\s]/g, '');\n      const result = clean.replace(/(\\d{3})(\\d{3})(\\d{4})/, (match, $1, $2, $3) => `(${$1}) ${$2}-${$3}`);\n      return result;\n    }\n\n    static getQueryParamsFromString(paramString) {\n      if (!paramString) {\n        return null;\n      }\n\n      const params = {};\n\n      for (const param of paramString.split('&')) {\n        const keyValue = Utilities.splitInTwo(param, '=');\n        params[keyValue.firstPart] = keyValue.secondPart;\n      }\n\n      return params;\n    }\n\n    static camelize(str) {\n      if (!str) {\n        return str;\n      }\n\n      return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => {\n        return index === 0 ? word.toLowerCase() : word.toUpperCase();\n      }).replace(/\\s+/g, '');\n    }\n\n    static getVariableCaseInsensitive(object, variableName) {\n      let result;\n\n      if (object != null && variableName != null) {\n        const variableNameLower = variableName.toLowerCase();\n        result = Object.getOwnPropertyNames(object).find(objPropName => objPropName.toLowerCase() === variableNameLower);\n      }\n\n      return result;\n    }\n\n    static allPropertiesAreUnset(object) {\n      const setProperties = [];\n      Object.getOwnPropertyNames(object).forEach(prop => {\n        if (object[prop] != null) {\n          setProperties.push(prop);\n        }\n      });\n      return setProperties.length === 0;\n    }\n\n    static somePropertiesSet(object) {\n      let set = false;\n      Object.getOwnPropertyNames(object).forEach(prop => {\n        if (!set && object[prop]) {\n          set = true;\n        }\n      });\n      return set;\n    }\n\n    static groupBy(xs, keyOrFunc) {\n      if (typeof keyOrFunc === 'string') {\n        const key = keyOrFunc;\n        return xs.reduce((rv, x) => {\n          (rv[x[key]] = rv[x[key]] || []).push(x);\n          return rv;\n        }, {});\n      } else {\n        const selectorFunction = keyOrFunc;\n        return xs.reduce((rv, x) => {\n          const key = selectorFunction(x);\n          (rv[key] = rv[key] || []).push(x);\n          return rv;\n        }, {});\n      }\n    }\n\n  }\n\n  Utilities.captionAndMessageSeparator = ':';\n  Utilities.noNetworkMessageCaption = 'No Network';\n  Utilities.noNetworkMessageDetail = 'The server cannot be reached';\n  Utilities.accessDeniedMessageCaption = 'Access Denied!';\n  Utilities.accessDeniedMessageDetail = '';\n  Utilities.notFoundMessageCaption = 'Not Found';\n  Utilities.notFoundMessageDetail = 'The target resource cannot be found';\n\n  Utilities.ɵfac = function Utilities_Factory(t) {\n    return new (t || Utilities)();\n  };\n\n  Utilities.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: Utilities,\n    factory: Utilities.ɵfac,\n    providedIn: 'root'\n  });\n  return Utilities;\n})();","map":null,"metadata":{},"sourceType":"module"}