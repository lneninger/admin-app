{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, isDevMode } from '@angular/core';\nimport { Subject, Observable } from 'rxjs';\nimport { __decorate, __metadata, __param } from 'tslib';\nimport { Computed, DataAction, Payload } from '@angular-ru/ngxs/decorators';\nimport { ensureSnapshot, ensureDataStateContext } from '@angular-ru/ngxs/internals';\nimport { sortByDesc, sortByAsc } from '@angular-ru/cdk/object';\nimport { PrimaryKey, SortOrderType } from '@angular-ru/cdk/typings';\nimport { isNil } from '@angular-ru/cdk/utils';\nimport { map } from 'rxjs/operators';\nlet AbstractRepository = /*#__PURE__*/(() => {\n  class AbstractRepository {\n    constructor() {\n      this.browserStorageEvents$ = new Subject();\n      this.isInitialised = false;\n      this.isBootstrapped = false;\n      this._dirty = true;\n    }\n\n    get dirty() {\n      return this._dirty;\n    }\n\n    set dirty(value) {\n      this._dirty = value;\n    }\n\n    ngxsOnChanges(_) {\n      var _a, _b;\n\n      if (this.dirty && this.isBootstrapped) {\n        this.dirty = false;\n        (_b = (_a = this).ngxsDataDoCheck) === null || _b === void 0 ? void 0 : _b.call(_a);\n      }\n    }\n\n    ngxsOnInit() {\n      this.isInitialised = true;\n    }\n\n    ngxsAfterBootstrap() {\n      var _a, _b;\n\n      this.isBootstrapped = true;\n\n      if (this.dirty) {\n        this.dirty = false;\n        (_b = (_a = this).ngxsDataDoCheck) === null || _b === void 0 ? void 0 : _b.call(_a);\n      }\n    }\n\n    markAsDirtyAfterReset() {\n      var _a, _b;\n\n      this.dirty = true;\n      (_b = (_a = this).ngxsDataAfterReset) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  AbstractRepository.ɵfac = function AbstractRepository_Factory(t) {\n    return new (t || AbstractRepository)();\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  AbstractRepository.ɵprov =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjectable({\n    token: AbstractRepository,\n    factory: AbstractRepository.ɵfac\n  });\n  return AbstractRepository;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AbstractNgxsDataRepository = /*#__PURE__*/(() => {\n  class AbstractNgxsDataRepository extends AbstractRepository {\n    get snapshot() {\n      return ensureSnapshot(this.getState());\n    }\n\n    get ctx() {\n      return ensureDataStateContext(this.context);\n    }\n\n    getState() {\n      return this.ctx.getState();\n    }\n\n    dispatch(actions) {\n      return this.ctx.dispatch(actions);\n    }\n\n    patchState(val) {\n      this.ctx.patchState(val);\n    }\n\n    setState(stateValue) {\n      this.ctx.setState(stateValue);\n    }\n\n    reset() {\n      this.ctx.setState(this.initialState);\n      this.markAsDirtyAfterReset();\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  AbstractNgxsDataRepository.ɵfac =\n  /** @pureOrBreakMyCode */\n  function () {\n    let ɵAbstractNgxsDataRepository_BaseFactory;\n    return function AbstractNgxsDataRepository_Factory(t) {\n      return (ɵAbstractNgxsDataRepository_BaseFactory || (ɵAbstractNgxsDataRepository_BaseFactory = i0.ɵɵgetInheritedFactory(AbstractNgxsDataRepository)))(t || AbstractNgxsDataRepository);\n    };\n  }();\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  AbstractNgxsDataRepository.ɵprov =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjectable({\n    token: AbstractNgxsDataRepository,\n    factory: AbstractNgxsDataRepository.ɵfac\n  });\n\n  __decorate([Computed(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], AbstractNgxsDataRepository.prototype, \"snapshot\", null);\n\n  __decorate([DataAction(), __param(0, Payload('patchValue')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataRepository.prototype, \"patchState\", null);\n\n  __decorate([DataAction(), __param(0, Payload('stateValue')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataRepository.prototype, \"setState\", null);\n\n  __decorate([DataAction(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataRepository.prototype, \"reset\", null);\n\n  return AbstractNgxsDataRepository;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AbstractNgxsDataEntityCollectionsRepository = /*#__PURE__*/(() => {\n  class AbstractNgxsDataEntityCollectionsRepository extends AbstractRepository {\n    constructor() {\n      super(...arguments);\n      this.primaryKey = PrimaryKey.ID;\n      this.comparator = null;\n    }\n\n    get snapshot() {\n      return ensureSnapshot(this.getState());\n    }\n\n    get ids() {\n      return this.snapshot.ids;\n    }\n\n    get entities() {\n      return this.snapshot.entities;\n    }\n\n    get entitiesArray() {\n      const snapshot = this.snapshot;\n      return snapshot.ids.map(id => snapshot.entities[id]);\n    }\n\n    get ids$() {\n      return this.state$.pipe(map(value => value.ids));\n    }\n\n    get entities$() {\n      return this.state$.pipe(map(value => value.entities));\n    }\n\n    get entitiesArray$() {\n      return this.state$.pipe(map(value => value.ids.map(id => value.entities[id])));\n    }\n\n    get ctx() {\n      return ensureDataStateContext(this.context);\n    }\n\n    setComparator(comparator) {\n      this.comparator = comparator;\n      return this;\n    }\n\n    dispatch(actions) {\n      return this.ctx.dispatch(actions);\n    }\n\n    getState() {\n      return this.ctx.getState();\n    }\n\n    selectId(entity) {\n      var _a;\n\n      return (_a = entity) === null || _a === void 0 ? void 0 : _a[this.primaryKey];\n    }\n\n    selectOne(id) {\n      var _a;\n\n      return (_a = this.snapshot.entities[id]) !== null && _a !== void 0 ? _a : null;\n    }\n\n    selectAll() {\n      const state = this.getState();\n      return state.ids.map(id => state.entities[id]);\n    }\n\n    reset() {\n      this.setEntitiesState(this.initialState);\n      this.markAsDirtyAfterReset();\n    }\n\n    addOne(entity) {\n      this.addEntityOne(entity);\n    }\n\n    addMany(entities) {\n      this.addEntitiesMany(entities);\n    }\n\n    setOne(entity) {\n      this.setEntityOne(entity);\n    }\n\n    setMany(entities) {\n      this.setEntitiesMany(entities);\n    }\n\n    setAll(entities) {\n      this.setEntitiesAll(entities);\n    }\n\n    updateOne(update) {\n      this.updateEntitiesMany([update]);\n    }\n\n    updateMany(updates) {\n      this.updateEntitiesMany(updates);\n    }\n\n    upsertOne(entity) {\n      this.upsertEntitiesMany([entity]);\n    }\n\n    upsertMany(entities) {\n      this.upsertEntitiesMany(entities);\n    }\n\n    removeOne(id) {\n      this.removeEntitiesMany([id]);\n    }\n\n    removeMany(ids) {\n      this.removeEntitiesMany(ids);\n    }\n\n    removeByEntity(entity) {\n      const id = this.selectId(entity);\n      this.removeEntitiesMany([id]);\n    }\n\n    removeByEntities(entities) {\n      const ids = [];\n\n      for (const entity of entities) {\n        const id = this.selectId(entity);\n        ids.push(id);\n      }\n\n      this.removeEntitiesMany(ids);\n    }\n\n    removeAll() {\n      this.setEntitiesState(this.initialState);\n    }\n\n    sort(comparator) {\n      this.comparator = comparator !== null && comparator !== void 0 ? comparator : this.comparator;\n\n      if (isNil(this.comparator)) {\n        console.warn(\"You must set the compare function before sorting.\"\n        /* NGXS_COMPARE */\n        );\n        return;\n      }\n\n      this.setEntitiesState(this.getState());\n    }\n\n    addEntityOne(entity) {\n      const state = this.getState();\n      const id = this.selectIdValue(entity);\n\n      if (id in state.entities) {\n        return;\n      }\n\n      this.setEntitiesState(Object.assign(Object.assign({}, state), {\n        ids: [...state.ids, id],\n        entities: Object.assign(Object.assign({}, state.entities), {\n          [id]: entity\n        })\n      }));\n    }\n\n    addEntitiesMany(entities) {\n      const state = this.getState();\n      const dictionary = {};\n      const ids = [];\n\n      for (const entity of entities) {\n        const id = this.selectIdValue(entity);\n\n        if (id in state.entities || id in dictionary) {\n          continue;\n        }\n\n        ids.push(id);\n        dictionary[id] = entity;\n      }\n\n      if (ids.length) {\n        this.setEntitiesState(Object.assign(Object.assign({}, state), {\n          ids: [...state.ids, ...ids],\n          entities: Object.assign(Object.assign({}, state.entities), dictionary)\n        }));\n      }\n    }\n\n    setEntitiesAll(entities) {\n      const state = this.getState();\n      const dictionary = {};\n      const ids = [];\n\n      for (const entity of entities) {\n        const id = this.selectIdValue(entity);\n\n        if (id in dictionary) {\n          continue;\n        }\n\n        ids.push(id);\n        dictionary[id] = entity;\n      }\n\n      this.setEntitiesState(Object.assign(Object.assign({}, state), {\n        ids,\n        entities: dictionary\n      }));\n    }\n\n    setEntityOne(entity) {\n      const state = this.getState();\n      const id = this.selectIdValue(entity);\n\n      if (id in state.entities) {\n        this.setEntitiesState(Object.assign(Object.assign({}, state), {\n          entities: Object.assign(Object.assign({}, state.entities), {\n            [id]: entity\n          })\n        }));\n      } else {\n        this.setEntitiesState(Object.assign(Object.assign({}, state), {\n          ids: [...state.ids, id],\n          entities: Object.assign(Object.assign({}, state.entities), {\n            [id]: entity\n          })\n        }));\n      }\n    }\n\n    setEntitiesMany(entities) {\n      for (const entity of entities) {\n        this.setEntityOne(entity);\n      }\n    } // eslint-disable-next-line max-lines-per-function\n\n\n    updateEntitiesMany(updates) {\n      const state = this.getState();\n      const newUpdates = updates.filter(update => update.id in state.entities);\n\n      if (newUpdates.length === 0) {\n        return;\n      }\n\n      const keys = this.generateKeyMap(state);\n      const entities = Object.assign({}, state.entities);\n\n      for (const update of newUpdates) {\n        const updated = this.updateOrigin(entities, update);\n        const newId = this.selectIdValue(updated);\n\n        if (newId !== update.id) {\n          delete keys[update.id];\n          delete entities[update.id];\n        }\n\n        keys[update.id] = newId;\n        entities[newId] = updated;\n      }\n\n      this.setEntitiesState(Object.assign(Object.assign({}, state), {\n        ids: state.ids.map(id => {\n          var _a;\n\n          return (_a = keys[id]) !== null && _a !== void 0 ? _a : id;\n        }),\n        entities\n      }));\n    }\n\n    upsertEntitiesMany(entities) {\n      const state = this.getState();\n      const updates = [];\n      const added = [];\n\n      for (const entity of entities) {\n        const id = this.selectIdValue(entity);\n\n        if (id in state.entities) {\n          updates.push({\n            id,\n            changes: entity\n          });\n        } else {\n          added.push(entity);\n        }\n      }\n\n      this.updateMany(updates);\n      this.addMany(added);\n    }\n\n    removeEntitiesMany(ids) {\n      const state = this.getState();\n      const keys = this.generateKeyMap(state);\n      const entities = Object.assign({}, state.entities);\n\n      for (const id of ids) {\n        if (id in entities) {\n          delete keys[id];\n          delete entities[id];\n        }\n      }\n\n      this.setEntitiesState(Object.assign(Object.assign({}, state), {\n        ids: state.ids.filter(id => id in keys),\n        entities\n      }));\n    }\n\n    setEntitiesState(state) {\n      const ids = this.sortKeysByComparator(state.ids, state.entities);\n      this.ctx.setState(Object.assign(Object.assign({}, state), {\n        ids,\n        entities: state.entities\n      }));\n    }\n\n    sortKeysByComparator(originalIds, entities) {\n      if (isNil(this.comparator)) {\n        return originalIds;\n      }\n\n      const ids = originalIds.slice();\n      const comparator = this.comparator;\n\n      if (typeof comparator === 'function') {\n        return ids.sort((a, b) => comparator(entities[a], entities[b]));\n      }\n\n      return this.sortByComparatorOptions(ids, comparator, entities);\n    }\n\n    sortByComparatorOptions(ids, comparator, entities) {\n      switch (comparator === null || comparator === void 0 ? void 0 : comparator.sortByOrder) {\n        case SortOrderType.ASC:\n          return ids.sort((a, b) => sortByAsc(comparator === null || comparator === void 0 ? void 0 : comparator.sortBy, entities[a], entities[b]));\n\n        case SortOrderType.DESC:\n          return ids.sort((a, b) => sortByDesc(comparator === null || comparator === void 0 ? void 0 : comparator.sortBy, entities[a], entities[b]));\n\n        default:\n          if (isDevMode()) {\n            console.warn(`Invalid --> { sortByOrder: \"${comparator === null || comparator === void 0 ? void 0 : comparator.sortByOrder}\" } not supported!`);\n          }\n\n          return ids;\n      }\n    }\n\n    generateKeyMap(state) {\n      return state.ids.reduce((keyDictionary, id) => {\n        keyDictionary[id] = id;\n        return keyDictionary;\n      }, {});\n    }\n\n    updateOrigin(entities, update) {\n      const original = entities[update.id];\n      return Object.assign(Object.assign({}, original), update.changes);\n    }\n\n    selectIdValue(entity) {\n      const id = this.selectId(entity);\n      const invalidId = isNil(id) && isDevMode();\n\n      if (invalidId) {\n        console.warn(`The entity passed to the 'selectId' implementation returned ${id}.`, `You should probably provide your own 'selectId' implementation.`, 'The entity that was passed:', entity, 'The current `selectId` implementation: (entity: V): K => entity.id');\n      }\n\n      return id;\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  AbstractNgxsDataEntityCollectionsRepository.ɵfac =\n  /** @pureOrBreakMyCode */\n  function () {\n    let ɵAbstractNgxsDataEntityCollectionsRepository_BaseFactory;\n    return function AbstractNgxsDataEntityCollectionsRepository_Factory(t) {\n      return (ɵAbstractNgxsDataEntityCollectionsRepository_BaseFactory || (ɵAbstractNgxsDataEntityCollectionsRepository_BaseFactory = i0.ɵɵgetInheritedFactory(AbstractNgxsDataEntityCollectionsRepository)))(t || AbstractNgxsDataEntityCollectionsRepository);\n    };\n  }();\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  AbstractNgxsDataEntityCollectionsRepository.ɵprov =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjectable({\n    token: AbstractNgxsDataEntityCollectionsRepository,\n    factory: AbstractNgxsDataEntityCollectionsRepository.ɵfac\n  });\n\n  __decorate([Computed(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], AbstractNgxsDataEntityCollectionsRepository.prototype, \"snapshot\", null);\n\n  __decorate([Computed(), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [])], AbstractNgxsDataEntityCollectionsRepository.prototype, \"ids\", null);\n\n  __decorate([Computed(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], AbstractNgxsDataEntityCollectionsRepository.prototype, \"entities\", null);\n\n  __decorate([Computed(), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [])], AbstractNgxsDataEntityCollectionsRepository.prototype, \"entitiesArray\", null);\n\n  __decorate([Computed(), __metadata(\"design:type\", Observable), __metadata(\"design:paramtypes\", [])], AbstractNgxsDataEntityCollectionsRepository.prototype, \"ids$\", null);\n\n  __decorate([Computed(), __metadata(\"design:type\", Observable), __metadata(\"design:paramtypes\", [])], AbstractNgxsDataEntityCollectionsRepository.prototype, \"entities$\", null);\n\n  __decorate([Computed(), __metadata(\"design:type\", Observable), __metadata(\"design:paramtypes\", [])], AbstractNgxsDataEntityCollectionsRepository.prototype, \"entitiesArray$\", null);\n\n  __decorate([DataAction(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"reset\", null);\n\n  __decorate([DataAction(), __param(0, Payload('entity')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"addOne\", null);\n\n  __decorate([DataAction(), __param(0, Payload('entities')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Array]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"addMany\", null);\n\n  __decorate([DataAction(), __param(0, Payload('entity')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"setOne\", null);\n\n  __decorate([DataAction(), __param(0, Payload('entities')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Array]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"setMany\", null);\n\n  __decorate([DataAction(), __param(0, Payload('entities')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Array]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"setAll\", null);\n\n  __decorate([DataAction(), __param(0, Payload('update')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"updateOne\", null);\n\n  __decorate([DataAction(), __param(0, Payload('updates')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Array]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"updateMany\", null);\n\n  __decorate([DataAction(), __param(0, Payload('entity')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"upsertOne\", null);\n\n  __decorate([DataAction(), __param(0, Payload('entities')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Array]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"upsertMany\", null);\n\n  __decorate([DataAction(), __param(0, Payload('id')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"removeOne\", null);\n\n  __decorate([DataAction(), __param(0, Payload('ids')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Array]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"removeMany\", null);\n\n  __decorate([DataAction(), __param(0, Payload('entity')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"removeByEntity\", null);\n\n  __decorate([DataAction(), __param(0, Payload('entities')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Array]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"removeByEntities\", null);\n\n  __decorate([DataAction(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"removeAll\", null);\n\n  __decorate([DataAction(), __param(0, Payload('comparator')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsDataEntityCollectionsRepository.prototype, \"sort\", null);\n\n  return AbstractNgxsDataEntityCollectionsRepository;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AbstractNgxsImmutableDataRepository = /*#__PURE__*/(() => {\n  class AbstractNgxsImmutableDataRepository extends AbstractRepository {\n    get snapshot() {\n      return ensureSnapshot(this.getState());\n    }\n\n    get ctx() {\n      return ensureDataStateContext(this.context);\n    }\n\n    getState() {\n      return this.ctx.getState();\n    }\n\n    dispatch(actions) {\n      return this.ctx.dispatch(actions);\n    }\n\n    patchState(val) {\n      this.ctx.patchState(val);\n    }\n\n    setState(stateValue) {\n      this.ctx.setState(stateValue);\n    }\n\n    reset() {\n      this.ctx.setState(this.initialState);\n      this.markAsDirtyAfterReset();\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  AbstractNgxsImmutableDataRepository.ɵfac =\n  /** @pureOrBreakMyCode */\n  function () {\n    let ɵAbstractNgxsImmutableDataRepository_BaseFactory;\n    return function AbstractNgxsImmutableDataRepository_Factory(t) {\n      return (ɵAbstractNgxsImmutableDataRepository_BaseFactory || (ɵAbstractNgxsImmutableDataRepository_BaseFactory = i0.ɵɵgetInheritedFactory(AbstractNgxsImmutableDataRepository)))(t || AbstractNgxsImmutableDataRepository);\n    };\n  }();\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  AbstractNgxsImmutableDataRepository.ɵprov =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjectable({\n    token: AbstractNgxsImmutableDataRepository,\n    factory: AbstractNgxsImmutableDataRepository.ɵfac\n  });\n\n  __decorate([Computed(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], AbstractNgxsImmutableDataRepository.prototype, \"snapshot\", null);\n\n  __decorate([DataAction(), __param(0, Payload('patchValue')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsImmutableDataRepository.prototype, \"patchState\", null);\n\n  __decorate([DataAction(), __param(0, Payload('stateValue')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AbstractNgxsImmutableDataRepository.prototype, \"setState\", null);\n\n  __decorate([DataAction(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], AbstractNgxsImmutableDataRepository.prototype, \"reset\", null);\n\n  return AbstractNgxsImmutableDataRepository;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AbstractRepository as NgxsAbstractDataRepository, AbstractNgxsDataEntityCollectionsRepository as NgxsDataEntityCollectionsRepository, AbstractNgxsDataRepository as NgxsDataRepository, AbstractNgxsImmutableDataRepository as NgxsImmutableDataRepository }; //# sourceMappingURL=angular-ru-ngxs-repositories.js.map","map":null,"metadata":{},"sourceType":"module"}