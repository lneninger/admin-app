{"ast":null,"code":"import { environment } from './../../../../environments/environment';\nimport { HTTP_INTERCEPTORS, HttpHeaders } from '@angular/common/http';\nimport { BehaviorSubject, throwError } from 'rxjs';\nimport { catchError, filter, take, switchMap, finalize } from 'rxjs/operators';\nimport { EndpointFactory } from '../endpoint-factory.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"../../services/user/user.service\";\nimport * as i3 from \"@ngxs/store\";\nimport * as i4 from \"../error/error-service\";\nimport * as i5 from \"./../../services/user/auth.service\";\nexport const KeepOriginalHeadersKey = 'keep-original';\nexport const NoAuthorizationHeaderKey = 'no-authorization';\nexport let SecurityHttpIOnterceptor = /*#__PURE__*/(() => {\n  class SecurityHttpIOnterceptor {\n    constructor(router, userService, store, errorService, authService) {\n      this.router = router;\n      this.userService = userService;\n      this.store = store;\n      this.errorService = errorService;\n      this.authService = authService;\n      this.refreshTokenInProgress = false;\n      this.refreshTokenSubject = new BehaviorSubject(null);\n    }\n\n    intercept(req, next) {\n      // debugger;\n      const formattedRequest = this.formatRequest(req);\n      return next.handle(formattedRequest).pipe(catchError(error => {\n        if (error && error.status === 401) {\n          // 401 errors are most likely going to be because we have an expired token that we need to refresh.\n          let request = null;\n\n          if (this.refreshTokenInProgress) {\n            // If refreshTokenInProgress is true, we will wait until refreshTokenSubject has a non-null value\n            // which means the new token is ready and we can retry the request again\n            request = this.refreshTokenSubject.asObservable().pipe(filter(result => result !== null), take(1), switchMap(() => next.handle(this.formatRequest(req))));\n          } else {\n            this.refreshTokenInProgress = true; // Set the refreshTokenSubject to null so that subsequent API calls will wait until the new token has been retrieved\n\n            this.refreshTokenSubject.next(null);\n            const token = ''; //this.authService.reLogin();\n\n            this.refreshTokenSubject.next(token);\n            request = next.handle(this.formatRequest(req)).pipe(finalize(() => this.refreshTokenInProgress = false));\n          }\n\n          return request.pipe(catchError(errorLast => {\n            console.log('Request error', {\n              error,\n              req\n            });\n\n            if (errorLast && errorLast.status === 401) {\n              this.redirectToError401(req);\n              return throwError(errorLast);\n            }\n          }));\n        } else {\n          console.log('Request error', {\n            error,\n            req\n          });\n          return throwError(error);\n        }\n      }));\n    }\n\n    formatRequest(req) {\n      // return req;\n      const token = this.store.selectSnapshot(store => {\n        // debugger;\n        return store.authState.token;\n      });\n      const defaultAuthorizationHeaders = {\n        Authorization: req.headers.has('Authorization') && req.headers.get('Authorization') != undefined ? req.headers.get('Authorization') : 'Bearer ' + token\n      };\n      const defaultHeaders = Object.assign(Object.assign({}, defaultAuthorizationHeaders), {\n        'Content-Type': req.headers.has('Content-Type') ? req.headers.get('Content-Type') : 'application/json',\n        Accept: req.headers.has('Accept') ? req.headers.get('Accept') : `application/vnd.iman.v${EndpointFactory.apiVersion}+json, application/json, text/plain, */*`,\n        'App-Version': req.headers.has('App-Version') ? req.headers.get('App-Version') : environment.appVersion\n      });\n      let result;\n\n      if (req.headers.get(KeepOriginalHeadersKey)) {\n        let headers = req.headers;\n        headers = headers.delete(KeepOriginalHeadersKey);\n\n        if (!req.headers.get(NoAuthorizationHeaderKey)) {\n          headers = req.headers.delete(NoAuthorizationHeaderKey);\n          headers = headers.set('Authorization', req.headers.has('Authorization') ? req.headers.get('Authorization') : 'Bearer ' + this.store.selectSnapshot(store => store.authState.token));\n        }\n\n        result = req.clone({\n          headers\n        });\n      } else {\n        result = req.clone({\n          headers: new HttpHeaders(defaultAuthorizationHeaders)\n        });\n      }\n\n      return result;\n    } // private refreshAccessToken(): Observable<string> {\n    //   return this.userService.acquireToken();\n    // }\n\n\n    redirectToError401(req) {\n      this.errorService.error401(req);\n    }\n\n  }\n\n  SecurityHttpIOnterceptor.ɵfac = function SecurityHttpIOnterceptor_Factory(t) {\n    return new (t || SecurityHttpIOnterceptor)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.UserService), i0.ɵɵinject(i3.Store), i0.ɵɵinject(i4.ErrorService), i0.ɵɵinject(i5.AuthService));\n  };\n\n  SecurityHttpIOnterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: SecurityHttpIOnterceptor,\n    factory: SecurityHttpIOnterceptor.ɵfac\n  });\n  return SecurityHttpIOnterceptor;\n})();\nexport const httpInterceptorProviders = [{\n  provide: HTTP_INTERCEPTORS,\n  useClass: SecurityHttpIOnterceptor,\n  multi: true\n}];","map":null,"metadata":{},"sourceType":"module"}