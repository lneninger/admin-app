{"ast":null,"code":"import { checkValueIsEmpty, isNil, isNotNil, isTrue, $any } from '@angular-ru/cdk/utils';\n\nfunction replaceUndefinedOrNull(_, value) {\n  return checkValueIsEmpty(value) ? undefined : value;\n}\n\nfunction clean(obj) {\n  return JSON.parse(JSON.stringify(obj, replaceUndefinedOrNull));\n}\n\nfunction checkIsShallowEmpty(definition) {\n  return Object.keys(clean(definition !== null && definition !== void 0 ? definition : {})).length === 0;\n}\n\nfunction deepClone(value) {\n  return isNil(value) ? value : JSON.parse(JSON.stringify(value));\n} // eslint-disable-next-line max-lines-per-function\n\n\nconst deepFreeze = value => {\n  const isObject = typeof value === 'object' && value !== null;\n  const isDate = value instanceof Date;\n  const skipFreeze = !isObject || isDate;\n\n  if (skipFreeze) {\n    return value;\n  }\n\n  Object.freeze(value);\n  const oIsFunction = typeof value === 'function'; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n  const hasOwnProp = Object.prototype.hasOwnProperty; // eslint-disable-next-line complexity\n\n  Object.getOwnPropertyNames(value).forEach(prop => {\n    if (hasOwnProp.call(value, prop) && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) && value[prop] !== null && (typeof value[prop] === 'object' || typeof value[prop] === 'function') && !Object.isFrozen(value[prop])) {\n      deepFreeze(value[prop]);\n    }\n  });\n  return value;\n};\n\nfunction firstKey(obj) {\n  var _a;\n\n  return (_a = Object.keys(obj !== null && obj !== void 0 ? obj : {})[0]) !== null && _a !== void 0 ? _a : null;\n} // eslint-disable-next-line complexity\n\n\nfunction getValueByPath(obj, path, fallback = undefined) {\n  var _a, _b, _c;\n\n  if (((_a = path === null || path === void 0 ? void 0 : path.length) !== null && _a !== void 0 ? _a : 0) < 1) {\n    return obj;\n  }\n\n  let result = obj;\n  const parts = (_b = path === null || path === void 0 ? void 0 : path.split('.')) !== null && _b !== void 0 ? _b : [];\n  let index = 0;\n\n  for (; isNotNil(result) && index < parts.length; ++index) {\n    const localIndex = parts === null || parts === void 0 ? void 0 : parts[index];\n    result = (_c = result) === null || _c === void 0 ? void 0 : _c[localIndex];\n  }\n\n  return result !== null && result !== void 0 ? result : fallback;\n}\n\nfunction instanceOfPlainObject(plainObject) {\n  return Object.prototype.toString.call(plainObject) === '[object Object]';\n}\n\nfunction isSimpleObject(value) {\n  return isNotNil(value) && typeof value == 'object' && instanceOfPlainObject(value);\n}\n\nfunction isGetter(obj, prop) {\n  var _a;\n\n  let currentObj = obj;\n  let result = false;\n\n  if (isSimpleObject(currentObj)) {\n    while (currentObj !== null) {\n      if (isTrue(currentObj === null || currentObj === void 0 ? void 0 : currentObj.hasOwnProperty(prop))) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        result = Boolean((_a = Object.getOwnPropertyDescriptor(currentObj, prop)) === null || _a === void 0 ? void 0 : _a.get);\n        break;\n      } else {\n        currentObj = Object.getPrototypeOf(currentObj);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction isIterable(value) {\n  return isNotNil(value) && typeof value[Symbol.iterator] === 'function';\n}\n\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\nfunction isPlainObject(plainObject) {\n  let constructorRef;\n  let prototypeRef;\n\n  if (!instanceOfPlainObject(plainObject)) {\n    return false;\n  } // If has modified constructor\n  // eslint-disable-next-line prefer-const\n\n\n  constructorRef = plainObject.constructor;\n\n  if (constructorRef === undefined) {\n    return true;\n  } // If has modified prototype\n  // eslint-disable-next-line prefer-const\n\n\n  prototypeRef = constructorRef.prototype;\n\n  if (!instanceOfPlainObject(prototypeRef)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prototypeRef.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n} // eslint-disable-next-line complexity\n\n\nfunction pathsOfObject(value, parentKey = null, keys = []) {\n  for (const key in value) {\n    if (!value.hasOwnProperty(key)) {\n      continue;\n    }\n\n    const element = value[key];\n    const isObjectValue = typeof element === 'object' && element !== null && !Array.isArray(element); // note: don't use isString for preserve circular dependencies\n\n    const implicitKey = typeof parentKey === 'string' ? `${parentKey}.${key}` : key;\n\n    if (isObjectValue) {\n      pathsOfObject(value[key], implicitKey, keys);\n    } else {\n      keys.push(implicitKey);\n    }\n  }\n\n  return keys;\n}\n\nfunction replaceWithNull(value) {\n  return JSON.parse(JSON.stringify(value, (_, elem) => {\n    if (typeof elem === 'object') {\n      return elem;\n    }\n\n    return checkValueIsEmpty(elem) ? null : elem;\n  }));\n}\n\nfunction shallowMapObject(object, mapper) {\n  const result = {};\n\n  for (const key in object) {\n    if (object.hasOwnProperty(key)) {\n      result[key] = mapper(object[key], key);\n    }\n  }\n\n  return result;\n}\n\nfunction sortByAsc(key, a, b) {\n  if ($any(a === null || a === void 0 ? void 0 : a[key]) > $any(b === null || b === void 0 ? void 0 : b[key])) {\n    return 1;\n  } else {\n    return $any(a === null || a === void 0 ? void 0 : a[key]) < $any(b === null || b === void 0 ? void 0 : b[key]) ? -1 : 0;\n  }\n}\n\nfunction sortByDesc(key, a, b) {\n  if ($any(a === null || a === void 0 ? void 0 : a[key]) > $any(b === null || b === void 0 ? void 0 : b[key])) {\n    return -1;\n  } else {\n    return $any(a === null || a === void 0 ? void 0 : a[key]) < $any(b === null || b === void 0 ? void 0 : b[key]) ? 1 : 0;\n  }\n}\n\nfunction unwrap(target, options) {\n  return Object.keys(target).sort().reduce((accumulator, key) => {\n    var _a;\n\n    return deepObjectReduce({\n      key,\n      accumulator,\n      targetValue: (_a = target) === null || _a === void 0 ? void 0 : _a[key],\n      options\n    });\n  }, {});\n}\n\nfunction flatten(object, excludeKeys = []) {\n  const depthGraph = {};\n\n  for (const key in object) {\n    if (object.hasOwnProperty(key) && !excludeKeys.includes(key)) {\n      mutate(object, depthGraph, key);\n    }\n  }\n\n  return depthGraph;\n}\n\nfunction mutate(object, depthGraph, key) {\n  const isObjectLike = typeof object[key] === 'object' && object[key] !== null;\n\n  if (isObjectLike) {\n    const flatObject = flatten(object[key]);\n\n    for (const path in flatObject) {\n      if (flatObject.hasOwnProperty(path)) {\n        depthGraph[`${key}.${path}`] = flatObject[path];\n      }\n    }\n  } else {\n    depthGraph[key] = object[key];\n  }\n}\n\nfunction deepObjectReduce({\n  accumulator,\n  key,\n  targetValue,\n  options\n}) {\n  let value = targetValue;\n\n  if (isTrue(options.weekType)) {\n    const isComplexType = typeof targetValue === 'object' && targetValue !== null;\n    value = isComplexType ? targetValue : String(checkValueIsEmpty(targetValue) ? null : targetValue);\n  }\n\n  accumulator[key] = getComparableValue(options, value);\n  return accumulator;\n}\n\nfunction comparable(target, options = {}) {\n  let result = target;\n\n  if (!isObject(result)) {\n    return result;\n  }\n\n  if (Array.isArray(target)) {\n    result = target.map(value => getComparableValue(options, value));\n  } else {\n    result = unwrap(target, options);\n  }\n\n  return result;\n}\n\nfunction objectToString(obj, options = {}) {\n  return JSON.stringify(comparable(obj, options));\n}\n\nfunction equals(a, b, options = {}) {\n  return objectToString(a, options) === objectToString(b, options);\n}\n\nfunction shallowTrimProperties(obj) {\n  return Object.entries(obj).reduce((result, [key, value]) => {\n    // note: don't use isString for preserve circular dependencies\n    result[key] = typeof value === 'string' ? value.trim() : value;\n    return result;\n  }, {});\n}\n\nfunction strictEquals(a, b) {\n  const options = {\n    weekType: true,\n    deep: true\n  };\n  return objectToString(a, options) === objectToString(b, options);\n}\n\nfunction getComparableValue(options, value) {\n  return isTrue(options.deep) ? comparable(value, options) : value;\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { checkIsShallowEmpty, clean, comparable, deepClone, deepFreeze, deepObjectReduce, equals, firstKey, flatten, getComparableValue, getValueByPath, isGetter, isIterable, isObject, isPlainObject, isSimpleObject, mutate, objectToString, pathsOfObject, replaceWithNull, shallowMapObject, shallowTrimProperties, sortByAsc, sortByDesc, strictEquals, unwrap }; //# sourceMappingURL=angular-ru-cdk-object.js.map","map":null,"metadata":{},"sourceType":"module"}