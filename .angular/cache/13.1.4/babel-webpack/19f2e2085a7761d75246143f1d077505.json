{"ast":null,"code":"import { isGetter, deepClone, isSimpleObject, deepFreeze } from '@angular-ru/cdk/object';\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, NgZone, Inject, isDevMode } from '@angular/core';\nimport * as i1 from '@ngxs/store';\nimport { Store } from '@ngxs/store';\nimport { BehaviorSubject, ReplaySubject, forkJoin, isObservable } from 'rxjs';\nimport { isNil, isNotNil, checkValueIsEmpty, isTruthy, isFalsy } from '@angular-ru/cdk/utils';\nimport { NGXS_DATA_META, NGXS_COMPUTED_OPTION, NGXS_ARGUMENT_REGISTRY_META, NGXS_META_KEY } from '@angular-ru/ngxs/tokens';\nimport { NGXS_STATE_FACTORY, NGXS_STATE_CONTEXT_FACTORY } from '@ngxs/store/internals';\nimport { map, shareReplay } from 'rxjs/operators';\n\nfunction validateAction(target, descriptor) {\n  const isStaticMethod = target.hasOwnProperty('prototype');\n\n  if (isStaticMethod) {\n    throw new Error(\"Cannot support static methods with @DataAction()\"\n    /* NGXS_DATA_STATIC_ACTION */\n    );\n  }\n\n  if (descriptor === undefined) {\n    throw new Error(\"@DataAction() can only decorate a method implementation\"\n    /* NGXS_DATA_ACTION */\n    );\n  }\n}\n\nfunction validateComputedMethod(target, name) {\n  const notGetter = !isGetter(target, name === null || name === void 0 ? void 0 : name.toString());\n\n  if (notGetter) {\n    throw new Error(`${\"The method must be a getter for the computed decorator to work properly.\"\n    /* NGXS_COMPUTED_DECORATOR */\n    }\\nExample: \\n@Computed() get ${name.toString()}() { \\n\\t .. \\n}`);\n  }\n}\n\nlet NgxsDataSequence = /*#__PURE__*/(() => {\n  class NgxsDataSequence {\n    constructor(store) {\n      this.sequence$ = new BehaviorSubject(0);\n      this.subscription = null;\n\n      if (store) {\n        this.subscription = store.subscribe(() => this.updateSequence());\n      }\n    }\n\n    get sequenceValue() {\n      return this.sequence$.getValue();\n    }\n\n    ngOnDestroy() {\n      var _a;\n\n      this.sequence$.next(0);\n      (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n\n    updateSequence() {\n      this.sequence$.next(this.sequenceValue + 1);\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  NgxsDataSequence.ɵfac = function NgxsDataSequence_Factory(t) {\n    return new (t || NgxsDataSequence)(i0.ɵɵinject(i1.Store, 8));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  NgxsDataSequence.ɵprov =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjectable({\n    token: NgxsDataSequence,\n    factory: NgxsDataSequence.ɵfac\n  });\n  return NgxsDataSequence;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction dynamicActionByType(type) {\n  return class NgxsDataAction {\n    constructor(payload) {\n      if (payload) {\n        Object.keys(payload).forEach(key => {\n          this[key] = payload[key];\n        });\n      }\n    }\n\n    static get type() {\n      return type;\n    }\n\n  };\n}\n\nfunction getRepository(target) {\n  return target[NGXS_DATA_META];\n}\n\nlet NgxsDataInjector = /*#__PURE__*/(() => {\n  class NgxsDataInjector {\n    constructor(injector, stateFactory, stateContextFactory) {\n      NgxsDataInjector.store = injector.get(Store);\n      NgxsDataInjector.ngZone = injector.get(NgZone);\n      NgxsDataInjector.factory = stateFactory;\n      NgxsDataInjector.context = stateContextFactory;\n      NgxsDataInjector.computed = injector.get(NgxsDataSequence);\n    }\n\n  }\n\n  NgxsDataInjector.store = null;\n  NgxsDataInjector.computed = null;\n  NgxsDataInjector.context = null;\n  NgxsDataInjector.factory = null;\n  NgxsDataInjector.ngZone = null;\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  NgxsDataInjector.ɵfac = function NgxsDataInjector_Factory(t) {\n    return new (t || NgxsDataInjector)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(NGXS_STATE_FACTORY), i0.ɵɵinject(NGXS_STATE_CONTEXT_FACTORY));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  NgxsDataInjector.ɵprov =\n  /** @pureOrBreakMyCode */\n  i0.ɵɵdefineInjectable({\n    token: NgxsDataInjector,\n    factory: NgxsDataInjector.ɵfac\n  });\n  return NgxsDataInjector;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass NgxsDataFactory {\n  constructor() {\n    NgxsDataFactory.statesCachedMeta.clear();\n  }\n\n  static createStateContext(metadata) {\n    return NgxsDataInjector.context.createStateContext(metadata);\n  }\n\n  static ensureMappedState(stateMeta) {\n    if (isNil(NgxsDataInjector.factory) || isNil(stateMeta)) {\n      throw new Error(\"Metadata not created \\n Maybe you forgot to import the NgxsDataPluginModule\\n Also, you cannot use this.ctx.* until the application is fully rendered \\n (use by default ngxsOnInit(ctx: StateContext), or ngxsAfterBootstrap(ctx: StateContext) !!!\"\n      /* NGXS_DATA_MODULE_EXCEPTION */\n      );\n    }\n\n    const cachedMeta = (isNotNil(stateMeta.name) ? NgxsDataFactory.statesCachedMeta.get(stateMeta.name) : null) || null;\n\n    if (!cachedMeta) {\n      return NgxsDataFactory.ensureMeta(stateMeta);\n    }\n\n    return cachedMeta;\n  }\n\n  static getRepositoryByInstance(target) {\n    var _a;\n\n    const stateClass = NgxsDataFactory.getStateClassByInstance(target);\n    const repository = (_a = getRepository(stateClass)) !== null && _a !== void 0 ? _a : null;\n\n    if (isNil(repository)) {\n      throw new Error(\"You forgot add decorator @StateRepository or initialize state!\\nExample: NgxsModule.forRoot([ .. ]), or NgxsModule.forFeature([ .. ])\"\n      /* NGXS_DATA_STATE_DECORATOR */\n      );\n    }\n\n    return repository;\n  }\n\n  static getStateClassByInstance(target) {\n    return (target !== null && target !== void 0 ? target : {}).constructor;\n  }\n\n  static clearMetaByInstance(target) {\n    const repository = NgxsDataFactory.getRepositoryByInstance(target);\n    repository.stateMeta.actions = {};\n    repository.operations = {};\n  }\n\n  static createPayload(args, registry) {\n    const payload = {};\n    const arrayArgs = Array.from(args);\n\n    for (let index = 0; index < arrayArgs.length; index++) {\n      const payloadName = registry === null || registry === void 0 ? void 0 : registry.getPayloadTypeByIndex(index);\n\n      if (isNotNil(payloadName)) {\n        payload[payloadName] = arrayArgs[index];\n      }\n    }\n\n    return Object.keys(payload).length > 0 ? payload : null;\n  }\n\n  static createAction(operation, args, registry) {\n    const payload = NgxsDataFactory.createPayload(args, registry);\n    const dynamicActionByTypeFactory = dynamicActionByType(operation.type);\n    return new dynamicActionByTypeFactory(payload);\n  }\n\n  static ensureMeta(stateMeta) {\n    var _a;\n\n    const meta = isNotNil(stateMeta.name) ? (_a = NgxsDataInjector.factory.states) === null || _a === void 0 ? void 0 : _a.find(state => state.name === stateMeta.name) : null;\n\n    if (isNotNil(meta) && isNotNil(stateMeta.name)) {\n      NgxsDataFactory.statesCachedMeta.set(stateMeta.name, meta);\n    }\n\n    return meta;\n  }\n\n}\n\nNgxsDataFactory.statesCachedMeta = new Map();\n/** @nocollapse */\n\n/** @nocollapse */\n\nNgxsDataFactory.ɵfac = function NgxsDataFactory_Factory(t) {\n  return new (t || NgxsDataFactory)();\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNgxsDataFactory.ɵprov =\n/** @pureOrBreakMyCode */\ni0.ɵɵdefineInjectable({\n  token: NgxsDataFactory,\n  factory: NgxsDataFactory.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst STORAGE_INIT_EVENT = {\n  firstInitialized: false,\n  events$: new ReplaySubject(1)\n};\n\nfunction actionNameCreator(options) {\n  const {\n    statePath,\n    argumentsNames,\n    methodName,\n    argumentRegistry\n  } = options;\n  let argsList = '';\n\n  for (let index = 0; index < argumentsNames.length; index++) {\n    if (isNotNil(argumentRegistry === null || argumentRegistry === void 0 ? void 0 : argumentRegistry.getArgumentNameByIndex(index))) {\n      argsList += argumentRegistry === null || argumentRegistry === void 0 ? void 0 : argumentRegistry.getArgumentNameByIndex(index);\n    } else if (isNotNil(argumentRegistry === null || argumentRegistry === void 0 ? void 0 : argumentRegistry.getPayloadTypeByIndex(index))) {\n      argsList += argumentRegistry === null || argumentRegistry === void 0 ? void 0 : argumentRegistry.getPayloadTypeByIndex(index);\n    } else {\n      argsList += `$arg${index}`;\n    }\n\n    if (index !== argumentsNames.length - 1) {\n      argsList += ', ';\n    }\n  }\n\n  return `@${statePath.replace(/\\./g, '/')}.${methodName}(${argsList})`;\n}\n\nclass InvalidChildrenException extends Error {\n  constructor(currentDefaults) {\n    super(`${\"Child states can only be added to an object\"\n    /* NGXS_DATA_CHILDREN_CONVERT */\n    }. Cannot convert ${isNotNil(currentDefaults === null || currentDefaults === void 0 ? void 0 : currentDefaults.constructor) ? currentDefaults.constructor.name : currentDefaults} to PlainObject`);\n  }\n\n}\n\nfunction getStoreOptions(stateClass) {\n  var _a;\n\n  return (_a = stateClass.NGXS_OPTIONS_META) !== null && _a !== void 0 ? _a : {\n    name: ''\n  };\n}\n\nfunction buildDefaultsGraph(stateClasses) {\n  var _a;\n\n  const options = getStoreOptions(stateClasses);\n  const children = (_a = options.children) !== null && _a !== void 0 ? _a : [];\n  const prepared = options.defaults === undefined ? {} : options.defaults;\n  const currentDefaults = deepClone(prepared);\n\n  if (children.length) {\n    if (isSimpleObject(currentDefaults)) {\n      return buildChildrenGraph(currentDefaults, children);\n    } else {\n      throw new InvalidChildrenException(currentDefaults);\n    }\n  } else {\n    return currentDefaults;\n  }\n}\n\nfunction buildChildrenGraph(currentDefaults, children) {\n  return children.reduce((defaults, item) => {\n    const childrenOptions = getStoreOptions(item);\n\n    if (checkValueIsEmpty(childrenOptions.name)) {\n      throw new Error(\"State name not provided in class\"\n      /* NGXS_DATA_STATE_NAME_NOT_FOUND */\n      );\n    }\n\n    const name = childrenOptions.name.toString();\n    defaults[name] = buildDefaultsGraph(item);\n    return defaults;\n  }, currentDefaults !== null && currentDefaults !== void 0 ? currentDefaults : {});\n}\n\nfunction checkExistNgZone() {\n  if (isNil(NgxsDataInjector.ngZone)) {\n    throw new Error(\"Metadata not created \\n Maybe you forgot to import the NgxsDataPluginModule\\n Also, you cannot use this.ctx.* until the application is fully rendered \\n (use by default ngxsOnInit(ctx: StateContext), or ngxsAfterBootstrap(ctx: StateContext) !!!\"\n    /* NGXS_DATA_MODULE_EXCEPTION */\n    );\n  }\n}\n\nfunction combineStream(dispatched$, result$) {\n  return forkJoin([dispatched$, result$]).pipe(map(combines => combines.pop()));\n}\n\nfunction computedKey() {\n  return `__${NGXS_COMPUTED_OPTION}__`;\n}\n\nfunction getComputedCache(target) {\n  var _a;\n\n  return (_a = target[computedKey()]) !== null && _a !== void 0 ? _a : null;\n}\n\nfunction ensureComputedCache(target) {\n  const cache = getComputedCache(target);\n\n  if (isNil(cache)) {\n    Object.defineProperties(target, {\n      [computedKey()]: {\n        enumerable: true,\n        configurable: true,\n        value: new WeakMap()\n      }\n    });\n  }\n\n  return getComputedCache(target);\n}\n\nfunction globalSequenceId() {\n  var _a, _b;\n\n  return (_b = (_a = NgxsDataInjector === null || NgxsDataInjector === void 0 ? void 0 : NgxsDataInjector.computed) === null || _a === void 0 ? void 0 : _a.sequenceValue) !== null && _b !== void 0 ? _b : 0;\n}\n\nfunction itObservable(value) {\n  let observable = false;\n\n  if (isObservable(value)) {\n    observable = true;\n  }\n\n  return observable;\n}\n\nfunction getMethodArgsRegistry(method) {\n  return method[NGXS_ARGUMENT_REGISTRY_META];\n}\n\nclass InvalidArgsNamesException extends Error {\n  constructor(name, method) {\n    super(`An argument with the name '${name}' already exists in the method '${method}'`);\n  }\n\n}\n\nclass MethodArgsRegistry {\n  constructor() {\n    this.payloadMap = new Map();\n    this.argumentMap = new Map();\n  }\n\n  getPayloadTypeByIndex(index) {\n    var _a;\n\n    return (_a = this.payloadMap.get(index)) !== null && _a !== void 0 ? _a : null;\n  }\n\n  getArgumentNameByIndex(index) {\n    var _a;\n\n    return (_a = this.argumentMap.get(index)) !== null && _a !== void 0 ? _a : null;\n  }\n\n  createPayloadType(name, method, paramIndex) {\n    this.checkDuplicateName(name, method);\n    this.payloadMap.set(paramIndex, name);\n    this.payloadMap.set(name, name);\n  }\n\n  createArgumentName(name, method, paramIndex) {\n    this.checkDuplicateName(name, method);\n    this.argumentMap.set(paramIndex, name);\n    this.argumentMap.set(name, name);\n  }\n\n  checkDuplicateName(name, method) {\n    if (isTruthy(this.argumentMap.has(name)) || isTruthy(this.payloadMap.has(name))) {\n      throw new InvalidArgsNamesException(name, method);\n    }\n  }\n\n}\n\nfunction ensureMethodArgsRegistry(target, propertyKey) {\n  const originMethod = target[propertyKey];\n  const registry = getMethodArgsRegistry(originMethod);\n\n  if (isNil(registry)) {\n    Object.defineProperties(originMethod, {\n      [NGXS_ARGUMENT_REGISTRY_META]: {\n        enumerable: true,\n        configurable: true,\n        value: new MethodArgsRegistry()\n      }\n    });\n  }\n\n  return getMethodArgsRegistry(originMethod);\n}\n\nfunction defineDefaultRepositoryMeta(target) {\n  Object.defineProperty(target, NGXS_DATA_META, {\n    writable: true,\n    configurable: true,\n    enumerable: true,\n    value: {\n      stateMeta: null,\n      operations: {},\n      stateClass: target\n    }\n  });\n}\n/**\n * @description\n * don't use !target.hasOwnProperty(NGXS_DATA_META),\n * because you need support access from parent inheritance class\n */\n\n\nfunction ensureRepository(target) {\n  var _a;\n\n  const repository = (_a = getRepository(target)) !== null && _a !== void 0 ? _a : null;\n  const metaNotFound = isNil(repository) || (repository === null || repository === void 0 ? void 0 : repository.stateClass) !== target;\n\n  if (metaNotFound) {\n    defineDefaultRepositoryMeta(target);\n  }\n\n  return getRepository(target);\n}\n/**\n * @description need mutate metadata for correct reference\n */\n\n\nfunction createRepositoryMetadata(target, stateMeta) {\n  const repositoryMeta = ensureRepository(target);\n  repositoryMeta.stateMeta = stateMeta;\n}\n\nfunction ensureSnapshot(state) {\n  return isDevMode() ? deepFreeze(state) : state;\n}\n\nfunction createContext(stateClass) {\n  return {\n    enumerable: true,\n    configurable: true,\n\n    get() {\n      const meta = getRepository(stateClass);\n      const mappedMeta = NgxsDataFactory.ensureMappedState(meta.stateMeta);\n      return NgxsDataFactory.createStateContext(mappedMeta);\n    }\n\n  };\n} // eslint-disable-next-line max-lines-per-function,sonarjs/cognitive-complexity\n\n\nfunction createStateSelector(stateClass) {\n  var _a, _b;\n\n  const repository = getRepository(stateClass);\n  const name = (_b = (_a = repository === null || repository === void 0 ? void 0 : repository.stateMeta) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : null;\n\n  if (isNotNil(name)) {\n    const selectorId = `__${name}__selector`;\n    Object.defineProperties(stateClass.prototype, {\n      [selectorId]: {\n        writable: true,\n        enumerable: false,\n        configurable: true\n      },\n      state$: {\n        enumerable: true,\n        configurable: true,\n\n        get() {\n          if (isNotNil(this[selectorId])) {\n            return this[selectorId];\n          } else {\n            if (isNil(NgxsDataInjector.store)) {\n              throw new Error(\"Metadata not created \\n Maybe you forgot to import the NgxsDataPluginModule\\n Also, you cannot use this.ctx.* until the application is fully rendered \\n (use by default ngxsOnInit(ctx: StateContext), or ngxsAfterBootstrap(ctx: StateContext) !!!\"\n              /* NGXS_DATA_MODULE_EXCEPTION */\n              );\n            }\n\n            this[selectorId] = NgxsDataInjector.store.select(stateClass).pipe(map(state => isDevMode() ? deepFreeze(state) : state), shareReplay({\n              refCount: true,\n              bufferSize: 1\n            }));\n          }\n\n          return this[selectorId];\n        }\n\n      }\n    });\n  }\n}\n\nfunction ensureDataStateContext(context) {\n  if (!context) {\n    throw new Error(\"You forgot add decorator @StateRepository or initialize state!\\nExample: NgxsModule.forRoot([ .. ]), or NgxsModule.forFeature([ .. ])\"\n    /* NGXS_DATA_STATE_DECORATOR */\n    );\n  }\n\n  return Object.assign(Object.assign({}, context), {\n    getState() {\n      return isDevMode() ? deepFreeze(context.getState()) : context.getState();\n    },\n\n    setState(val) {\n      context.setState(val);\n    },\n\n    patchState(val) {\n      context.patchState(val);\n    }\n\n  });\n}\n\nfunction getStateMetadata(target) {\n  var _a; // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n\n\n  return (_a = target) === null || _a === void 0 ? void 0 : _a[NGXS_META_KEY];\n}\n\nfunction ensureStateMetadata(target) {\n  if (isFalsy(target.hasOwnProperty(NGXS_META_KEY))) {\n    const defaultMetadata = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n\n      makeRootSelector(context) {\n        return context.getStateGetter(defaultMetadata.name);\n      },\n\n      children: []\n    };\n    Object.defineProperty(target, NGXS_META_KEY, {\n      value: defaultMetadata\n    });\n  }\n\n  return getStateMetadata(target);\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MethodArgsRegistry, NgxsDataFactory, NgxsDataInjector, NgxsDataSequence, STORAGE_INIT_EVENT, actionNameCreator, buildDefaultsGraph, checkExistNgZone, combineStream, createContext, createRepositoryMetadata, createStateSelector, defineDefaultRepositoryMeta, dynamicActionByType, ensureComputedCache, ensureDataStateContext, ensureMethodArgsRegistry, ensureRepository, ensureSnapshot, ensureStateMetadata, getComputedCache, getMethodArgsRegistry, getRepository, getStateMetadata, getStoreOptions, globalSequenceId, itObservable, validateAction, validateComputedMethod }; //# sourceMappingURL=angular-ru-ngxs-internals.js.map","map":null,"metadata":{},"sourceType":"module"}