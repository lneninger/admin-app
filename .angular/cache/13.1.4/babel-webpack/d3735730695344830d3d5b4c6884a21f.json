{"ast":null,"code":"import { isTrue, isNil, isNotNil, isFalsy } from '@angular-ru/cdk/utils';\nimport { validateComputedMethod, ensureComputedCache, globalSequenceId, itObservable, validateAction, NgxsDataFactory, getMethodArgsRegistry, actionNameCreator, NgxsDataInjector, combineStream, checkExistNgZone, ensureMethodArgsRegistry, ensureStateMetadata, getRepository, STORAGE_INIT_EVENT, createRepositoryMetadata, buildDefaultsGraph, createStateSelector, createContext } from '@angular-ru/ngxs/internals';\nimport { $args } from '@angular-ru/cdk/function';\nimport { isObservable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { isDevMode } from '@angular/core';\nimport { ensureProviders, registerStorageProviders } from '@angular-ru/ngxs/storage';\nimport { deepClone } from '@angular-ru/cdk/object'; // eslint-disable-next-line max-lines-per-function\n\nfunction Computed() {\n  // eslint-disable-next-line max-lines-per-function\n  return (target, key, descriptor) => {\n    validateComputedMethod(target, key);\n    const originalMethod = descriptor.get;\n\n    descriptor.get = function (...args) {\n      const cacheMap = ensureComputedCache(this);\n      const cache = cacheMap === null || cacheMap === void 0 ? void 0 : cacheMap.get(originalMethod);\n\n      if (isTrue(cache === null || cache === void 0 ? void 0 : cache.isObservable)) {\n        return cache === null || cache === void 0 ? void 0 : cache.value;\n      }\n\n      const invalidCache = isNil(cache) || cache.sequenceId !== globalSequenceId();\n\n      if (invalidCache) {\n        cacheMap.delete(originalMethod);\n        const value = originalMethod.apply(this, args);\n        cacheMap.set(originalMethod, {\n          value,\n          sequenceId: globalSequenceId(),\n          isObservable: itObservable(value)\n        });\n        return value;\n      } else {\n        return cache.value;\n      }\n    };\n\n    return descriptor;\n  };\n}\n\nconst REPOSITORY_ACTION_OPTIONS = {\n  cancelUncompleted: true,\n  insideZone: false\n}; // eslint-disable-next-line max-lines-per-function\n\nfunction DataAction(options = REPOSITORY_ACTION_OPTIONS) {\n  // eslint-disable-next-line max-lines-per-function\n  return (target, name, descriptor) => {\n    validateAction(target, descriptor);\n    const originalMethod = descriptor.value;\n    const key = name.toString(); // eslint-disable-next-line max-lines-per-function\n\n    descriptor.value = function (...args) {\n      const instance = this;\n      let result = null;\n      const repository = NgxsDataFactory.getRepositoryByInstance(instance);\n      const operations = repository.operations;\n      let operation = operations[key];\n      const stateMeta = repository.stateMeta;\n      const registry = getMethodArgsRegistry(originalMethod);\n\n      if (isNil(operation)) {\n        // Note: late init operation when first invoke action method\n        const argumentsNames = $args(originalMethod);\n        const type = actionNameCreator({\n          statePath: stateMeta.path,\n          methodName: key,\n          argumentsNames,\n          argumentRegistry: registry\n        });\n        operation = operations[key] = {\n          type,\n          options: {\n            cancelUncompleted: options.cancelUncompleted\n          }\n        };\n        stateMeta.actions[operation.type] = [{\n          type: operation.type,\n          options: operation.options,\n          fn: operation.type\n        }];\n      }\n\n      const mapped = NgxsDataFactory.ensureMappedState(stateMeta);\n      const stateInstance = mapped.instance; // Note: invoke only after store.dispatch(...)\n\n      stateInstance[operation.type] = () => {\n        var _a;\n\n        if (isTrue(options.insideZone)) {\n          (_a = NgxsDataInjector.ngZone) === null || _a === void 0 ? void 0 : _a.run(() => {\n            result = originalMethod.apply(instance, args);\n          });\n        } else {\n          result = originalMethod.apply(instance, args);\n        } // Note: store.dispatch automatically subscribes, but we donâ€™t need it\n        // We want to subscribe ourselves manually\n\n\n        return isObservable(result) ? of(null).pipe(map(() => result)) : result;\n      };\n\n      const event = NgxsDataFactory.createAction(operation, args, registry);\n      const dispatcher$ = NgxsDataInjector.store.dispatch(event);\n\n      if (isObservable(result)) {\n        return combineStream(dispatcher$, result);\n      } else {\n        return result;\n      }\n    };\n\n    return descriptor;\n  };\n}\n\nconst DEFAULT_TIMEOUT = 300;\n\nfunction Debounce(timeout = DEFAULT_TIMEOUT) {\n  let timeoutRef = null;\n  return (_target, _name, descriptor) => {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args) {\n      var _a;\n\n      checkExistNgZone();\n      (_a = NgxsDataInjector.ngZone) === null || _a === void 0 ? void 0 : _a.runOutsideAngular(() => {\n        window.clearTimeout(timeoutRef); // eslint-disable-next-line no-restricted-properties\n\n        timeoutRef = window.setTimeout(() => {\n          const result = originalMethod.apply(this, args);\n\n          if (isDevMode() && isNotNil(result)) {\n            console.warn(\"WARNING: If you use asynchronous actions `@Debounce() @DataAction()` the return result type should only void instead:\"\n            /* NGXS_DATA_ASYNC_ACTION_RETURN_TYPE */\n            , result);\n          }\n        }, timeout);\n      });\n    };\n\n    return descriptor;\n  };\n}\n\nfunction Named(name) {\n  return (stateClass, methodName, parameterIndex) => {\n    const key = name.trim();\n\n    if (!key) {\n      throw new Error(\"Argument name should be initialized\"\n      /* NGXS_INVALID_ARG_NAME */\n      );\n    }\n\n    const registry = ensureMethodArgsRegistry(stateClass, methodName);\n    registry.createArgumentName(key, methodName, parameterIndex);\n  };\n}\n\nfunction Payload(name) {\n  return (stateClass, methodName, parameterIndex) => {\n    const key = name.trim();\n\n    if (!key) {\n      throw new Error(\"Payload name should be initialized\"\n      /* NGXS_INVALID_PAYLOAD_NAME */\n      );\n    }\n\n    const registry = ensureMethodArgsRegistry(stateClass, methodName);\n    registry.createPayloadType(key, methodName, parameterIndex);\n  };\n}\n\nfunction Persistence(options) {\n  return stateClass => {\n    const stateMeta = ensureStateMetadata(stateClass);\n    const repositoryMeta = getRepository(stateClass);\n    const isUndecoratedClass = isNil(stateMeta.name) || isNil(repositoryMeta);\n\n    if (isUndecoratedClass) {\n      throw new Error(\"@Persistence should be add before decorator @State and @StateRepository\"\n      /* NGXS_PERSISTENCE_STATE */\n      );\n    }\n\n    STORAGE_INIT_EVENT.events$.subscribe(() => {\n      if (isFalsy(STORAGE_INIT_EVENT.firstInitialized)) {\n        STORAGE_INIT_EVENT.firstInitialized = true;\n      }\n\n      const providers = ensureProviders(repositoryMeta, stateClass, options);\n      registerStorageProviders(providers);\n    });\n  };\n}\n\nfunction StateRepository() {\n  return stateClass => {\n    const stateMeta = ensureStateMetadata(stateClass);\n\n    if (isNil(stateMeta.name)) {\n      throw new Error(\"@StateRepository should be add before decorator @State\"\n      /* NGXS_DATA_STATE */\n      );\n    }\n\n    createRepositoryMetadata(stateClass, stateMeta);\n    const cloneDefaults = buildDefaultsGraph(stateClass);\n    defineProperties(stateClass, stateMeta, cloneDefaults);\n    createStateSelector(stateClass);\n  };\n}\n\nfunction defineProperties(stateClass, stateMeta, cloneDefaults) {\n  Object.defineProperties(stateClass.prototype, {\n    name: {\n      enumerable: true,\n      configurable: true,\n      value: stateMeta.name\n    },\n    initialState: {\n      enumerable: true,\n      configurable: true,\n\n      get() {\n        // preserve mutation\n        return deepClone(cloneDefaults);\n      }\n\n    },\n    context: createContext(stateClass)\n  });\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Computed, DataAction, Debounce, Named, Payload, Persistence, StateRepository }; //# sourceMappingURL=angular-ru-ngxs-decorators.js.map","map":null,"metadata":{},"sourceType":"module"}